## 题目地址(169. 多数元素)

https://leetcode.cn/problems/majority-element/description

## 题目难度
- 简单

## 题目描述

```
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。
```

## 我的思路
最简单的方法就是用字典`dict`或者`hashmap`来遍历这个数组，然后直接返回其中出现次数最多的就行。由于此数据结构的插入和查找时间复杂度均为O(1)，因此这也是也是最好的方法之一。
```py
    # 哈希表计数法
    from collections import Counter
    def majorityElement_Counter(self, nums: List[int]) -> int:
        counts = Counter(nums)
        return max(counts, key=counts.get)
    
    # 使用字典计数法
    def majorityElement_Dict(self, nums: List[int]) -> int:
        counts = {}
        for num in nums:
            counts[num] = counts.get(num, 0) + 1
        return max(counts, key=counts.get)
```
有一个很巧妙的思路：我们可以把整个数组想象成 **「选举投票」**：
 - 多数元素 = 候选人
 - 出现一次 +1 票
 - 遇到不是候选人，就「抵消」一票

如果某个元素是多数元素（> n/2 次），那即使不断抵消，它最后一定能剩下来。
总结一下，摩尔投票核心思想是：**遇到相同的元素，就“站队”；遇到不同的元素，就“抵消”。最终剩下来的那个元素，如果它确实超过一半，就一定是多数元素**。

其实我也想到了分治法，不过当时思路是：
用递归的方式来二分这个数组nums，一直到分的组内只有两个元素位置，然后自底向上选出当前组内最多的元素。合并阶段，判断当前区间的“多数元素”是否存在。
这个思路的问题在：
| 问题点                | 原因                                   |
| ------------------ | ------------------------------------ |
| 试图让“每一小段都必须有多数”   | ❌ 错误理解，只有整段才保证有多数                    |
| 自底向上合并时考虑返回 None   | ❌ 不需要返回 None，返回当前段最可能的候选多数，然后靠计数验证即可 |
| 忽略了「比较候选多数出现次数」这一步 | 合并的核心逻辑:只需要在合并阶段比较两个候选多数的出现次数，就可以找出当前区间的多数。|

**正确的分治步骤为：**
1. **划分**
将数组从中间划分为左右两部分：
```py
left = helper(lo, mid)
right = helper(mid + 1, hi)
```
2. **合并**
如果两个子数组的多数元素是一样的，那它一定也是当前区间的多数元素。
如果不一样，说明当前区间的多数元素只可能是 left 或 right 中的一个。
所以我们统计这两个元素在当前区间内出现次数，返回次数多的那一个。

## 关键点
- 多数元素：在数组中出现次数**大于 ⌊ n/2 ⌋** 的元素。
- 众数的题型联想到摩尔投票
---
 - **延伸：**[摩尔投票和分治法的选择](../../Thinkings/摩尔投票vs分治法.md)
---
## 代码

Python Code:
[代码](./python_implement/solution.py)
```py
class Solution:
    # 摩尔投票法
    def majorityElement_Vote(self, nums: List[int]) -> int:
        major, vote = 0, 0
        for n in nums:
            if vote == 0:
                major = n
                vote = 1
            elif n == major:
                vote += 1
            else:
                vote -= 1
        return major
    
    # 哈希表计数法
    def majorityElement_Counter(self, nums: List[int]) -> int:
        counts = Counter(nums)
        return max(counts, key=counts.get)
    
    # 使用字典计数法
    def majorityElement_Dict(self, nums: List[int]) -> int:
        counts = {}
        for num in nums:
            counts[num] = counts.get(num, 0) + 1
        return max(counts, key=counts.get)
        
    # 分治法
    def majorityElement_DivMerge(self, nums: List[int]) -> int:
        def count_in_range(nums: List[int], target: int, low: int, high: int) -> int:
            # 用切片优化
            return nums[low:high+1].count(target)
            # 或者使用循环
            # return sum(1 for i in range(low, high + 1) if nums[i] == target)

        def majority(low: int, high: int) -> int:
            # base case: 只有一个元素
            if low == high:
                return nums[low]

            mid = (low + high) // 2
            left_majority = majority(low, mid)
            right_majority = majority(mid + 1, high)

            if left_majority == right_majority:
                return left_majority

            left_count = count_in_range(nums, left_majority, low, high)
            right_count = count_in_range(nums, right_majority, low, high)

            return left_majority if left_count > right_count else right_majority

        return majority(0, len(nums) - 1)
```