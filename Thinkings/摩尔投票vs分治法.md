# 💡 ✅ 摩尔投票 vs 分治

## 🌟 场景 & 适合任务

| 特点               | 摩尔投票                    | 分治法                            |
| ---------------- | ----------------------- | ------------------------------ |
| 🏷️ 是否需要保证存在多数元素 | ✅ 必须保证有多数（比如出现次数 > n/2） | ✅ 不需要显式保证（可以扩展）                |
| ⚡ 是否需要多次候选       | ❌ 原版只保留一个候选             | ✅ 每段都可以有独立候选                   |
| ⏱️ 复杂度           | 时间 O(n)，空间 O(1)         | 时间 O(n log n)，空间 O(log n)（递归栈） |
| 🎯 使用场景          | 单个多数元素 & 一定存在           | 需要区间统计、组合结果、多众数或多阶段合并          |

---

## ✅ 摩尔投票适用任务

* 数组 **一定存在一个超过一半的元素**（比如 [Leetcode 169.Majority Element](https://leetcode.cn/problems/majority-element/description)）
* 需要 **一趟扫描就找到**，并且不能开额外空间（比如数据流场景）
* 不需要记录每个候选人的次数，只关心最终胜者

🎯 **代表任务**

* 找唯一的多数元素（超过 n/2）
* 找唯一的超过 n/3（可扩展成多候选摩尔投票，比如 [Leetcode 229.Majority Element ii](https://leetcode.cn/problems/majority-element-ii/description/)）

---

## ✅ 分治法适用任务

* 不仅要找「多数元素」，还可能需要知道「各部分的统计信息」
* 需要在 **分块、分区间、分段处理** 时，保留子段的候选
* 要把子问题结果合并成全局解

🎯 **代表任务**

* 在大区间上找众数（任意多数或任意 top-k）
* 需要统计不同候选在不同子区间中的出现次数
* 可组合成复杂的并行或者分布式计算（比如 MapReduce）

---

## 💡 ✅ 思维方式对比

| 思维方式  | 摩尔投票         | 分治法          |
| ----- | ------------ | ------------ |
| 贪心/抵消 | ✅ 候选人思维，每次抵消 | ❌ 没有抵消，子问题合并 |
| 递归/合并 | ❌ 单次线性扫描     | ✅ 拆分递归、合并结果  |
| 全局信息  | ❌ 一次局部推全局    | ✅ 每段统计后再组合   |

---

## 🟢 实际例子再对比

### 🌟 Leetcode 169 （找超过 n/2 的那个元素）
[我们的题解](../OurSolutions/169.majority-element/169.majority-element.md)
* **摩尔投票**：一次扫描搞定，最优。
* **分治法**：可做，但复杂度更高，时间 O(n log n)，需要递归合并。

---

### 🌟 Leetcode 229（找超过 n/3 的所有元素）

* **摩尔投票**：可以保留两个候选人（最多两个元素超过 n/3）
* **分治法**：也可做，需要合并多个候选

---

### 🌟 区间众数（比如多个查询区间，每个区间找众数）

* **摩尔投票**：无法处理
* **分治法**：适合，可用树状结构（如分块/线段树）

---

# ✅ 总结一句话

> ⚡ **如果只需要找唯一多数且一定存在，优先用摩尔投票；如果需要统计、合并、支持多子问题，选分治法。**

