## 题目地址(88. 合并两个有序数组)

https://leetcode.cn/problems/remove-duplicates-from-sorted-array

## 题目难度
- 简单

## 题目描述

```
给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：

更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。
返回 k 。
```

## 我的思路
这里注意nums是递增排列！一开始没审题还以为是删除无序数组的重复项。有序数组的话就简单了：要求是原地，我们也不要开辟一个新数组了。
最容易想到的就是从前往后遍历遇到重复就删
```py
def removeDuplicates(self, nums: List[int]) -> int:
        i = 1
        while i < len(nums):
            if nums[i] == nums[i - 1]:
                del nums[i]
            else:
                i += 1
        return len(nums)
```
但是这样写时间复杂度为**O(n^2)**。且频繁移动数组。最坏情况复杂度接近 O(n²)

答案是有的！可以通过**双指针**的思想：一个指针p1从前往后遍历nums(稳定+1)，如果有不等于val的就塞入nums首部，另外一个指针p2就是用来记录塞入的索引，塞入后p2会+1。这样可以做到一次遍历且原地修改。这个塞入的操作你也可以理解为**入栈**。

## 关键点
- 利用双指针，将时间复杂度从 O(n^2) 降低到 O(n)

## 代码

Python Code:

```py
class Solution:
    # 直接remove然后sort
    def removeElement_Remove(self, nums: List[int], val: int) -> int:
        while val in nums:
            nums.remove(val)
        return len(nums)
    # 双指针
    def removeElement_Stack(self, nums: List[int], val: int) -> int:
        idx = 0
        for num in nums:
            if num != val:
                nums[idx] = num
                idx += 1
        return idx
```