## 题目地址(904. 水果成篮)

https://leetcode.cn/problems/fruit-into-baskets

## 题目难度
- 中等

## 题目描述

```
你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。
```

## 我的思路
由于题目中涉及到最大数目，一开始其实就想到了**滑动窗口 + deque**这个方法：用两个指针来记录[r一直往后，l用来记录左边界]:`res = max(res, r - l + 1)`。然后需要维护一个双向队列（数组也可以）来存当前的两种水果。
这里我们需要**更新左边界l**，因此用 temp 记录当前「第二种水果开始」的位置。**难点就在何时去更新这个temp**，下面我们进行分析：
显然，新的水果进来（即新进来的不在deque)中，我们需要更新左边界l为当下第二个水果（相对后进来的水果）进来时的索引（此时的temp）。然后再将temp更新为r。
这里容易漏掉另一种情况：当新进来的水果已在deque中，但是他不等于前一个元素: `fruits[r] != queue[-1]`, 这时其实我们需要更新deque并将temp更新为当前的索引r

其实还可以用dict(哈希表)来维护窗口 [l, r]：记录当前窗口中每种水果最后一次出现的位置（索引）即其value。
当出现第三种水果时，更新左边界 l，将字典中最左的那个元素删掉（窗口左端往右缩），窗口重新只保留两种。

## 关键点
- 滑动窗口 + deque/dict/list 维护当前窗口内的两种水果种类
- 当新的元素进来或者进来的元素已在deque内但是不等于右边的，这两种情况都需要更新temp

## 代码

Python Code:
[代码](./python_implement/solution.py)
```py
class Solution:
    def totalFruit_Deque(self, fruits: List[int]) -> int:
        if len(fruits) == 1:
            return 1

        queue = collections.deque()
        l = 0
        temp = 0
        res = 1

        for r in range(len(fruits)):
            if fruits[r] not in queue:
                if len(queue) == 2:
                    queue.popleft()
                    l = temp
                temp = r
                queue.append(fruits[r])
            else:
                if fruits[r] != queue[-1]:
                    queue.popleft()
                    temp = r
                    queue.append(fruits[r])
            res = max(res, r - l + 1)

        return res
    
    def totalFruit_Dict(self, fruits: List[int]) -> int:
        fruit_dict = {}  # key: 水果种类, value: 该水果最后一次出现的索引
        l = 0
        res = 0

        for r, fruit in enumerate(fruits):
            fruit_dict[fruit] = r

            if len(fruit_dict) > 2:
                # 找出最左边水果的最后索引
                min_idx = min(fruit_dict.values())
                # 更新左边界
                l = min_idx + 1
                # 从字典里删掉它
                del_fruit = [key for key, val in fruit_dict.items() if val == min_idx][0]
                del fruit_dict[del_fruit]

            res = max(res, r - l + 1)

        return res
```

### 性能对比
| 方法           | 时间复杂度 | 空间复杂度 |
| ------------ | ----- | ----- |
| deque + temp | O(n)  | O(1)  |
| dict + 滑窗    | O(n)  | O(1)  |

但是，我们在测试中发现：长输入情况下，deque方法更省时:见[测试截图](./测试截图.png)
这是因为**deque 的实现更接近原地操作**
deque 版本逻辑上是一个简单双端队列，手动维护了「第二种水果的起点」（temp）。
每次移动只需要 popleft() 或 append()，几乎无额外结构遍历，且在 CPython 里 deque.popleft() 是专门用「块链表」实现的，非常快。

Python dict 内部哈希 & rehash
Python 的 dict 在内部是哈希表结构，当元素频繁「插入、删除」时，会有 再哈希（rehash） 的细碎代价。
对于大规模数据流，每次哈希、key-value 结构构建、删除 key 等都涉及额外对象操作。