## 题目地址(80. 删除有序数组中的重复项 II)

https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii

## 题目难度
- 中等

## 题目描述

```
给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
```

## 我的思路
既然要求是原地修改，那我们也不要用del或remove来删除。这种对数组原地操作，第一个想到的方法就是**双指针**。
我们可以定义第一个指针idx来遍历数组内的元素，然后用第二个指针ptr来维护要写入新元素的位置，同时用 count 控制每个元素出现次数。如果新的元素nums[i]等于当前维护的元素nums[ptr]时，我们判断只有count小于2的情况才允许记录。如果有不等于的话，说明是不同于当前维护的nums[ptr]，这样我们允许记录，且将count重置/设置为1。
这种方法时间复杂度为 O(n),空间复杂度为 O(1)。
```py
def removeDuplicates_DoublePointers(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)
        ptr = 0
        count = 1 # 默认占一个
        for i in range(1, len(nums)):
            if nums[i] == nums[ptr]:
                if count < 2:
                    ptr += 1
                    nums[ptr] = nums[i]
                    count += 1
            else:
                ptr += 1
                nums[ptr] = nums[i]
                count = 1
        return ptr + 1
```
那有没有更好的办法？
想一想，我们这里count的作用是：判断当前元素是否已经出现超过 2 次，只要它出现超过两次就不能写入。
这里注意到我们**写过的部分**就是最终结果，即nums[0..ptr]。因为只允许最多保留 2 个相同元素，那我们只需要保证**当前元素（nums[i]）和倒数第二个写入的元素(nums[ptr - 2])不相等即可把当前元素写入**。这样我们就省去count和判断count的分支了。
这个nums[0..ptr]可以理解为是一个栈，写入即为入栈，
代码实现如下：
```py
def removeDuplicates_Stack(self, nums: List[int]) -> int:
        ptr = 2
        for i in range(2, len(nums)):
            if nums[i] != nums[ptr - 2]:
                nums[ptr] = nums[i]
                ptr += 1
        return min(ptr, len(nums))
```

## 关键点
- 利用栈的思想，简化了双指针的实现，节省了部分变量和分支判断

## 代码

Python Code:

```py
class Solution:
    def removeDuplicates_DoublePointers(self, nums: List[int]) -> int:
        if len(nums) <= 2:
            return len(nums)
        ptr = 0
        count = 1 # 默认占一个
        for i in range(1, len(nums)):
            if nums[i] == nums[ptr]:
                if count < 2:
                    ptr += 1
                    nums[ptr] = nums[i]
                    count += 1
            else:
                ptr += 1
                nums[ptr] = nums[i]
                count = 1
        return ptr + 1
    
    def removeDuplicates_Stack(self, nums: List[int]) -> int:
        ptr = 2
        for i in range(2, len(nums)):
            if nums[i] != nums[ptr - 2]:
                nums[ptr] = nums[i]
                ptr += 1
        return min(ptr, len(nums))
```